import {
  axios_default
} from "./chunk-DFJB7BCF.js";
import {
  inject,
  onMounted,
  reactive,
  ref
} from "./chunk-U3LI7FBV.js";
import "./chunk-PR4QN5HX.js";

// node_modules/@iankibetsh/vue-streamline/src/composables/useStreamline.js
var useStreamline = (stream, ...initialArgs) => {
  let formData = {};
  const loading = ref(false);
  const propertiesFetched = ref(false);
  const fetching = ref(false);
  const cacheKey = `streamline_${stream}_${initialArgs.join("_")}`;
  const streamlineUrl = inject("streamlineUrl");
  const streamlineHeaders = inject("streamlineHeaders");
  const enableCache = inject("enableCache");
  const originalProps = reactive({});
  const props = new Proxy(originalProps, {
    get(target, property, receiver) {
      if (!propertiesFetched.value) {
        fetchServiceProperties().then(() => target[property]);
      }
      return Reflect.get(target, property, receiver);
    },
    set(target, property, value, receiver) {
      return Reflect.set(target, property, value, receiver);
    }
  });
  const axios = axios_default.create({
    headers: {
      ...streamlineHeaders
    }
  });
  const fetchServiceProperties = async () => {
    if (loading.value || fetching.value || propertiesFetched.value) return;
    fetching.value = true;
    try {
      loading.value = true;
      const response = await axios.post(streamlineUrl, {
        action: "onMounted",
        stream,
        params: initialArgs
      });
      assignProperties(response.data);
      enableCache && localStorage.setItem(cacheKey, JSON.stringify(response.data));
    } catch (error) {
      console.error(`Error fetching properties for stream ${stream}`, error);
      throw error;
    } finally {
      propertiesFetched.value = true;
      fetching.value = false;
      loading.value = false;
    }
  };
  const assignProperties = (data) => {
    Object.assign(service, data.properties);
    Object.assign(originalProps, data.properties);
  };
  const handler = {
    get(target, prop, receiver) {
      if (!propertiesFetched.value && !loading.value) {
        fetchServiceProperties().then(() => target[prop]);
      }
      if (prop in target) {
        return target[prop];
      }
      return (...args) => {
        loading.value = true;
        return axios.post(streamlineUrl, {
          action: prop,
          stream,
          ...formData,
          params: args
        }).then((response) => {
          loading.value = false;
          return response.data;
        }).catch((error) => {
          loading.value = false;
          console.error(`Error calling ${prop} on stream ${stream}`, error);
          throw error;
        });
      };
    }
  };
  const getActionUrl = (action, ...args) => {
    const post = {
      action,
      stream,
      params: args
    };
    return `${streamlineUrl}?${new URLSearchParams(post).toString()}`;
  };
  const service = reactive({});
  onMounted(() => {
    if (!enableCache) return;
    const cachedData = localStorage.getItem(cacheKey);
    if (cachedData) {
      assignProperties(JSON.parse(cachedData));
    }
    if (initialArgs.length > 0) {
      fetchServiceProperties();
    }
  });
  return {
    loading,
    service: new Proxy(service, handler),
    getActionUrl,
    props
  };
};
var useStreamline_default = useStreamline;

// node_modules/@iankibetsh/vue-streamline/src/plugins/streamline.js
var streamline = {
  install(app, options) {
    app.provide("streamlineUrl", options.streamlineUrl);
    app.provide("streamlineHeaders", options.streamlineHeaders);
    app.provide("enableCache", options.enableCache);
  }
};
var streamline_default = streamline;
export {
  streamline_default as streamline,
  useStreamline_default as useStreamline
};
//# sourceMappingURL=@iankibetsh_vue-streamline.js.map
